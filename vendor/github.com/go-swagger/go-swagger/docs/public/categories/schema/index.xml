<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Schema on go-swagger toolkit</title>
    <link>//goswagger.io/categories/schema/</link>
    <description>Recent content in Schema on go-swagger toolkit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© 2016 go-swagger contributors</copyright>
    <lastBuildDate>Sat, 26 Dec 2015 15:39:43 -0800</lastBuildDate>
    <atom:link href="//goswagger.io/categories/schema/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Schema generation rules</title>
      <link>//goswagger.io/use/schemas/</link>
      <pubDate>Sat, 26 Dec 2015 15:39:43 -0800</pubDate>
      
      <guid>//goswagger.io/use/schemas/</guid>
      <description>

&lt;p&gt;Lots of the work of go-swagger is to generate models, which can have all kinds of rules like polymorphism and
validations.  Of course none of this is possible without set of rules and tradeoffs.&lt;/p&gt;

&lt;h3 id=&#34;about-schemas:176038017a790b96307b48b85dc07885&#34;&gt;About schemas&lt;/h3&gt;

&lt;p&gt;The general idea is that you should rarely see interface{} in the generated code.
You get a complete representation of a swagger document in somewhat idiomatic go.&lt;/p&gt;

&lt;p&gt;To do so there is set of mapping patterns that are applied to a spec to go types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;defintion of primitive =&amp;gt; type alias/name&lt;/li&gt;
&lt;li&gt;defintion of array =&amp;gt; type alias/name&lt;/li&gt;
&lt;li&gt;definition of map =&amp;gt; type alias/name&lt;/li&gt;
&lt;li&gt;definition of object with properties =&amp;gt; struct&lt;/li&gt;
&lt;li&gt;definition of ref =&amp;gt; type alias/name&lt;/li&gt;
&lt;li&gt;object with only additional properties =&amp;gt; map[string]T&lt;/li&gt;
&lt;li&gt;object with additional properties and properties =&amp;gt; custom serializer&lt;/li&gt;
&lt;li&gt;schema with schema array in items =&amp;gt; tuple (struct with properties, custom serializer)&lt;/li&gt;
&lt;li&gt;schema with all of =&amp;gt; struct&lt;/li&gt;
&lt;li&gt;all of schema with ref =&amp;gt; embedded value&lt;/li&gt;
&lt;li&gt;all of schema with properties =&amp;gt; properties are included in struct&lt;/li&gt;
&lt;li&gt;adding an all of schema with just &amp;ldquo;x-isnullable&amp;rdquo;: true or &amp;ldquo;x-nullable&amp;rdquo;: true turns
the schema into a pointer when there are only other extension properties provided&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JSONSchema and by extension swagger allow for items that have a fixed size array
with schema&amp;rsquo;s describing the items at each index. This can be combined with additional items
to form some kind of tuple with varargs.
To map this to go it creates a struct that has fixed names and a custom json serializer.&lt;/p&gt;

&lt;p&gt;The code that is generated also gets the doc comments that are used by the scanner
to generate a spec from go code. So that after generation you should be able to reverse
generate a spec from the code that was generated by your spec.&lt;/p&gt;

&lt;p&gt;It should be equivalent to the original spec but might miss some default values and examples.&lt;/p&gt;

&lt;h4 id=&#34;nullability:176038017a790b96307b48b85dc07885&#34;&gt;nullability&lt;/h4&gt;

&lt;p&gt;There are rules around what turns something into a pointer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;structs&lt;/li&gt;
&lt;li&gt;x-nullable, x-isnullable&lt;/li&gt;
&lt;li&gt;primitives where the zero value is valid but fail validation otherwise&lt;/li&gt;
&lt;li&gt;strings minLength &amp;gt; 0 or required results in non-pointer&lt;/li&gt;
&lt;li&gt;numbers min &amp;gt; 0, max &amp;lt; 0 and min &amp;lt; max&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
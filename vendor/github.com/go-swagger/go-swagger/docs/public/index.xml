<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go-swagger toolkit</title>
    <link>//goswagger.io/</link>
    <description>Recent content on go-swagger toolkit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2016 go-swagger contributors</copyright>
    <lastBuildDate>Wed, 30 Dec 2015 11:56:40 -0800</lastBuildDate>
    <atom:link href="//goswagger.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Todo List Tutorial</title>
      <link>//goswagger.io/tutorial/todo-list/</link>
      <pubDate>Wed, 30 Dec 2015 11:56:40 -0800</pubDate>
      
      <guid>//goswagger.io/tutorial/todo-list/</guid>
      <description>&lt;p&gt;This example walks you through a hypothetical project that is building a todo list.
It specifically uses a todo list because it&amp;rsquo;s a super well-understood application and hopefully this allows you to focus entirely on the new concepts. This example builds a server and then a client.&lt;/p&gt;

&lt;p&gt;When you start an application most likely you think about the functionality it supports.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;swagger init spec \
  --title &amp;quot;A To Do list application&amp;quot; \
  --description &amp;quot;The product of a tutorial on goswagger.io&amp;quot; \
  --version 1.0.0 \
  --scheme http \
  --consumes application/io.goswagger.examples.todo-list.v1+json \
  --produces application/io.goswagger.examples.todo-list.v1+json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can get started with a swagger.yml like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;consumes:
- application/io.goswagger.examples.todo-list.v1+json
definitions: {}
info:
  description: The product of a tutorial on goswagger.io
  title: A To Do list application
  version: 1.0.0
paths: {}
produces:
- application/io.goswagger.examples.todo-list.v1+json
schemes:
- http
swagger: &amp;quot;2.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This doesn&amp;rsquo;t do much but it would validate in the swagger validator step.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list
git:(master) ✗ ? » swagger validate ./swagger.yml
The swagger spec at &amp;quot;./swagger.yml&amp;quot; is valid against swagger specification 2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now you have an empty but valid specification document, time to get to declaring some models and endpoints for the API. You&amp;rsquo;ll probably need a model to represent a todo item, you can define that in the definitions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;definitions:
  item:
    type: object
    required:
      - description
    properties:
      id:
        type: integer
        format: int64
        readOnly: true
      description:
        type: string
        minLength: 1
      completed:
        type: boolean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this model definition we say that the model &lt;code&gt;item&lt;/code&gt; is an &lt;em&gt;object&lt;/em&gt; with a required property &lt;code&gt;description&lt;/code&gt;. This item model has 3 properties: id, description and completed. The &lt;code&gt;id&lt;/code&gt; property is an int64 value and is marked as &lt;em&gt;readOnly&lt;/em&gt;, so that means that it will be provided by the API server and it will be ignored when the item is created.
This document also says that the description must be at least 1 char long, this will result in a string property that&amp;rsquo;s &lt;a href=&#34;http://goswagger.io/use/schemas/#nullability:176038017a790b96307b48b85dc07885&#34;&gt;not a pointer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At this moment there is enough to get some actual code generated, but let&amp;rsquo;s wait with that and continue defining the rest of the API so that the code generation later on will be more useful. Now you have a model so you probably want to add some endpoints to list the todo&amp;rsquo;s.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;paths:
  /:
    get:
      tags:
        - todos
      responses:
        200:
          description: list the todo operations
          schema:
            type: array
            items:
              $ref: &amp;quot;#/definitions/item&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This snippet of yaml defines a &lt;code&gt;GET /&lt;/code&gt; operation, and tags it with &lt;em&gt;todos&lt;/em&gt;. Tagging things is nice because tools do all kinds of fancy things with tags. Tags help UI&amp;rsquo;s group endpoints appropriately, code generators might turn them into &amp;lsquo;controllers&amp;rsquo;. Furthermore there is a response defined with a generic description, about what&amp;rsquo;s in the response. Be aware that some generators think a field like that is a good thing to put in the http status message. And then of course the response defines also the return type of that endpoint. In this case the endpoint will be returning a list of todo items, so the schema is an &lt;em&gt;array&lt;/em&gt; and the array will contain items that look like the item definition you declared earlier.&lt;/p&gt;

&lt;p&gt;But wait a minute, what if there are 100&amp;rsquo;s of todo items, will we just return all of them for everybody?  It might be best to add a since and limit param here. The ids will have ordered for a since param to work but you&amp;rsquo;re in control of that so that&amp;rsquo;s fine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;paths:
  /:
    get:
      tags:
        - todos
      parameters:
        - name: since
          in: query
          type: integer
          format: int64
        - name: limit
          in: query
          type: integer
          format: int32
          default: 20
      responses:
        200:
          description: list the todo operations
          schema:
            type: array
            items:
              $ref: &amp;quot;#/definitions/item&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this new version of the operation YAML, there are query params now for the values and they define defaults so people can leave them off and the API will still function as intended.&lt;/p&gt;

&lt;p&gt;However  this definition is extremely optimistic and only defines a response for the &amp;ldquo;happy path&amp;rdquo;. It&amp;rsquo;s very likely that the API will need to return some form of error messages too. So that means you probably have to define a model for the error messages as well as at least one more response definition to cover both the bodies in you contract.&lt;/p&gt;

&lt;p&gt;The error definition might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;definitions:
  error:
    type: object
    required:
      - message
    properties:
      code:
        type: integer
        format: int64
      message:
        type: string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the extra response you can use the default response, because after all every successful response from your API is defying the odds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;paths:
  /:
    get:
      tags:
        - todos
      parameters:
        - name: since
          in: query
          type: integer
          format: int64
        - name: limit
          in: query
          type: integer
          format: int32
          default: 20
      responses:
        200:
          description: list the todo operations
          schema:
            type: array
            items:
              $ref: &amp;quot;#/definitions/item&amp;quot;
        default:
          description: generic error response
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you&amp;rsquo;ve got your first endpoint defined completely. To improve the strength of this contract you could define responses for each of the status codes and perhaps return a different error message. In this case the status code will be provided in the error message, and can easily be different from the HTTP status codes, who typically only give you a hint of what went wrong.&lt;/p&gt;

&lt;p&gt;Perhaps validate the specification again, having a valid swagger document, is important when using the code generation, there are quite a few factors that contribute to rendering the models for a specification. An invalid swagger document makes it so that the generated code will have unpredictable behavior.&lt;/p&gt;

&lt;p&gt;So the completed spec should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;swagger: &amp;quot;2.0&amp;quot;
info:
  description: The product of a tutorial on goswagger.io
  title: A To Do list application
  version: 1.0.0
consumes:
- application/io.goswagger.examples.todo-list.v1+json
produces:
- application/io.goswagger.examples.todo-list.v1+json
schemes:
- http
- https
paths:
  /:
    get:
      tags:
        - todos
      parameters:
        - name: since
          in: query
          type: integer
          format: int64
        - name: limit
          in: query
          type: integer
          format: int32
          default: 20
      responses:
        200:
          description: list the todo operations
          schema:
            type: array
            items:
              $ref: &amp;quot;#/definitions/item&amp;quot;
        default:
          description: generic error response
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
definitions:
  item:
    type: object
    required:
      - description
    properties:
      id:
        type: integer
        format: int64
        readOnly: true
      description:
        type: string
        minLength: 1
      completed:
        type: boolean
  error:
    type: object
    required:
      - message
    properties:
      code:
        type: integer
        format: int64
      message:
        type: string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you generate a server for this you&amp;rsquo;ll see the following directory listing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-1
git:(master) ✗ !? » swagger generate server -A TodoList -f ./swagger.yml
2016/02/15 12:32:40 building a plan for generation
2016/02/15 12:32:40 planning definitions
2016/02/15 12:32:40 planning operations
2016/02/15 12:32:40 grouping operations into packages
2016/02/15 12:32:40 planning meta data and facades
2016/02/15 12:32:40 rendering 2 models
2016/02/15 12:32:40 rendered model template: error
2016/02/15 12:32:40 rendered model template: item
2016/02/15 12:32:40 rendered handler template: todos.Get
2016/02/15 12:32:40 generated handler todos.Get
2016/02/15 12:32:40 rendered parameters template: todos.GetParameters
2016/02/15 12:32:40 generated parameters todos.GetParameters
2016/02/15 12:32:40 rendered responses template: todos.GetResponses
2016/02/15 12:32:40 generated responses todos.GetResponses
2016/02/15 12:32:40 rendered builder template: operations.TodoList
2016/02/15 12:32:40 rendered embedded Swagger JSON template: server.TodoList
2016/02/15 12:32:40 rendered configure api template: operations.ConfigureTodoList
2016/02/15 12:32:40 rendered doc template: operations.TodoList
2016/02/15 12:32:40 rendered main template: server.TodoList

± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-1
git:(master) ✗ !? » tree
.
├── cmd
│   └── todo-list-server
│       ├── configure_todo_list.go
│       ├── doc.go
│       ├── embedded_spec.go
│       └── main.go
├── models
│   ├── error.go
│   └── item.go
├── restapi
│   └── operations
│       ├── todo_list_api.go
│       └── todos
│           ├── get.go
│           ├── get_parameters.go
│           └── get_responses.go
└── swagger.yml

6 directories, 11 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this file tree you notice that there is a cmd/todo-list-server generated. The swagger generator adds -server to the application name (provided to the generated command through the -A argument).&lt;/p&gt;

&lt;p&gt;The second major section in this tree is the models package. This package contains go representations for both the defintions from the swagger spec document.&lt;/p&gt;

&lt;p&gt;And then the last major section is the rest api, within the rest api there is the code that is generated based on the information from the paths property in the swagger specification. The go swagger generator uses the tags to group the operations into packages.&lt;/p&gt;

&lt;p&gt;We skipped over naming operations, you have the ability to name the operations by giving operations an ID in the specification document. For example for the operation defintion with &lt;code&gt;operationId: findTodos&lt;/code&gt;, the following tree would be generated:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;.
├── cmd
│   └── todo-list-server
│       ├── configure_todo_list.go
│       ├── doc.go
│       ├── embedded_spec.go
│       └── main.go
├── models
│   ├── error.go
│   └── item.go
├── restapi
│   └── operations
│       ├── todo_list_api.go
│       └── todos
│           ├── find_todos.go
│           ├── find_todos_parameters.go
│           └── find_todos_responses.go
└── swagger.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you&amp;rsquo;re able to start the server, but lets first see what &amp;ndash;help gives you. To make this happen you can first install the binary and then run it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/.../examples/tutorials/todo-list/server-1
git:(master) ✗ -!? » go install ./cmd/todo-list-server/
± ivan@aether:~/go/src/.../examples/tutorials/todo-list/server-1
git:(master) ✗ -!? » todo-list-server --help
Usage:
  todo-list-server [OPTIONS]

The product of a tutorial on goswagger.io

Application Options:
      --host= the IP to listen on (default: localhost) [$HOST]
      --port= the port to listen on for insecure connections, defaults to a random value [$PORT]

Help Options:
  -h, --help  Show this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see your application can be run straightaway and it will use a random port value by default. This might not be what you want so you can configure a port with an argument or through an environment variable. Those env vars are chosen because many platforms (like heroku) use those to configure the apps they are running.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;git:(master) ✗ !? » todo-list-server
serving todo list at http://127.0.0.1:64637
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you can curl it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;git:(master) ✗ !? » curl -i http://127.0.0.1:64637/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 501 Not Implemented
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Thu, 31 Dec 2015 22:42:10 GMT
Content-Length: 57

&amp;quot;operation todos.FindTodos has not yet been implemented&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So immediately after generating, the API has limited usability, but this can serve as a sanity check. Your API will need more endpoints besides listing todo items. Because this tutorial highlights design first, we know we will need a few other things. In addition to listing the todo items the API will need a means to add a new todo item, update the description of one and mark a todo item as completed.&lt;/p&gt;

&lt;p&gt;For adding a todo item you probably want to define a POST operation, for our purposes that might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;paths:
  /:
    post:
      tags:
        - todos
      operationId: addOne
      parameters:
        - name: body
          in: body
          schema:
            $ref: &amp;quot;#/definitions/item&amp;quot;
      responses:
        201:
          description: Created
          schema:
            $ref: &amp;quot;#/definitions/item&amp;quot;
        default:
          description: error
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in this YAML snippet there is one new thing: you&amp;rsquo;re defining that your API has a POST body and that that should be the item model defined earlier. Earlier the item schema was defined with a readOnly id, so that means it doesn&amp;rsquo;t need to be included in the POST body. But the response to the POST request will include an id property. The next operation to define is the DELETE operation, where you delete a todo item from the list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;paths:
  /{id}:
    delete:
      tags:
        - todos
      operationId: destroyOne
      parameters:
        - type: integer
          format: int64
          name: id
          in: path
          required: true
      responses:
        204:
          description: Deleted
        default:
          description: error
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new concept in the DELETE method is that this time around you&amp;rsquo;re defining a path parameter. When you delete an item you need to provide an ID. This is typically done in the path of a resource, and that&amp;rsquo;s how this operation will know which todo item to delete. Once you&amp;rsquo;ve deleted something you can&amp;rsquo;t really return its data anymore, so the success response in this case is &lt;code&gt;204 No Content&lt;/code&gt;. At this point all you still require is a means to update an item, which combines everything you&amp;rsquo;ve just learnt.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;paths:
  /{id}:
    parameters:
      - type: integer
        format: int64
        name: id
        in: path
        required: true
    put:
      tags: [&amp;quot;todos&amp;quot;]
      operationId: updateOne
      parameters:
        - name: body
          in: body
          schema:
            $ref: &amp;quot;#/definitions/item&amp;quot;
      responses:
        &#39;200&#39;:
          description: OK
          schema:
            $ref: &amp;quot;#/definitions/item&amp;quot;
        default:
          description: error
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
    delete:
      # elided for brevity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For updates there are 2 approaches that people typically take: PUT indicates replace the entity, PATCH indicates only update the fields provided in the request. In this case the &amp;ldquo;brute force&amp;rdquo; approach of replacing an entire entity is taken. Another thing you see here is that because the id path parameter is shared between both the put and the delete method, there is an opportunity to DRY the operation definition up a bit. So the path parameter moved to the common parameters section for the path.&lt;/p&gt;

&lt;p&gt;At this point you should have a completed specification for the todo list API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;swagger: &amp;quot;2.0&amp;quot;
info:
  description: The product of a tutorial on goswagger.io
  title: A To Do list application
  version: 1.0.0
consumes:
- application/io.goswagger.examples.todo-list.v1+json
produces:
- application/io.goswagger.examples.todo-list.v1+json
schemes:
- http
- https
paths:
  /:
    get:
      tags:
        - todos
      operationId: findTodos
      parameters:
        - name: since
          in: query
          type: integer
          format: int64
        - name: limit
          in: query
          type: integer
          format: int32
          default: 20
      responses:
        200:
          description: list the todo operations
          schema:
            type: array
            items:
              $ref: &amp;quot;#/definitions/item&amp;quot;
        default:
          description: generic error response
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
    post:
      tags:
        - todos
      operationId: addOne
      parameters:
        - name: body
          in: body
          schema:
            $ref: &amp;quot;#/definitions/item&amp;quot;
      responses:
        201:
          description: Created
          schema:
            $ref: &amp;quot;#/definitions/item&amp;quot;
        default:
          description: error
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
  /{id}:
    parameters:
      - type: integer
        format: int64
        name: id
        in: path
        required: true
    put:
      tags:
        - todos
      operationId: updateOne
      parameters:
        - name: body
          in: body
          schema:
            $ref: &amp;quot;#/definitions/item&amp;quot;
      responses:
        200:
          description: OK
          schema:
            $ref: &amp;quot;#/definitions/item&amp;quot;
        default:
          description: error
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
    delete:
      tags:
        - todos
      operationId: destroyOne
      responses:
        204:
          description: Deleted
        default:
          description: error
          schema:
            $ref: &amp;quot;#/definitions/error&amp;quot;
definitions:
  item:
    type: object
    required:
      - description
    properties:
      id:
        type: integer
        format: int64
        readOnly: true
      description:
        type: string
        minLength: 1
      completed:
        type: boolean
  error:
    type: object
    required:
      - message
    properties:
      code:
        type: integer
        format: int64
      message:
        type: string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again this is a good time to sanity check, and run the validator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-2
git:(master) ✗ !? » swagger validate ./swagger.yml
The swagger spec at &amp;quot;./swagger.yml&amp;quot; is valid against swagger specification 2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;re ready to generate the API and start filling out some of the blanks.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;git:(master) ✗ !? » swagger generate server -A TodoList -f ./swagger.yml
... elided output ...
2015/12/31 18:16:28 rendered main template: server.TodoList
± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-2
git:(master) ✗ !? » tree
.
├── cmd
│   └── todo-list-server
│       ├── configure_todo_list.go
│       ├── doc.go
│       ├── embedded_spec.go
│       └── main.go
├── models
│   ├── error.go
│   └── item.go
├── restapi
│   └── operations
│       ├── todo_list_api.go
│       └── todos
│           ├── add_one.go
│           ├── add_one_parameters.go
│           ├── add_one_responses.go
│           ├── destroy_one.go
│           ├── destroy_one_parameters.go
│           ├── destroy_one_responses.go
│           ├── find_todos.go
│           ├── find_todos_parameters.go
│           ├── find_todos_responses.go
│           ├── update_one.go
│           ├── update_one_parameters.go
│           └── update_one_responses.go
└── swagger.yml

6 directories, 20 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you want to add functionality to your application, like adding your own code to the generated code, the place to do that is in the &lt;code&gt;configure_todo_list.go&lt;/code&gt; file. The configure_todo_list file is safe to edit, it won&amp;rsquo;t get overwritten in regeneration passes, to override the file you&amp;rsquo;d have to delete it yourself and regenerate.&lt;/p&gt;

&lt;p&gt;A good first implementation of the todo list api, can be one where everything is stored in a map. This should show that everything works, without the complications of dealing with a database yet.
For this you&amp;rsquo;ll need to track the state for an incrementing id and a structure to store items in.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// the variables we need throughout our implementation
var items = make(map[int64]*models.Item)
var lastID int64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The simplest handler to implement now is the delete handler. Because the store is a map and the id of the item is provided in the request it&amp;rsquo;s a one liner.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;api.TodosDestroyOneHandler = todos.DestroyOneHandlerFunc(func(params todos.DestroyOneParams) middleware.Responder {
  delete(items, params.ID)
  return todos.NewDestroyOneNoContent()
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After deleting the item from the store, there is a responder that needs to be created. The code generator has generated responders for each response you defined in the the swagger specification. The other 3 handler implementations are pretty similar to this one, they are provided in the &lt;a href=&#34;https://github.com/go-swagger/go-swagger/blob/master/examples/tutorials/todo-list/server-complete/cmd/todo-list-server/configure_todo_list.go&#34;&gt;source for this tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;re all set now, with a spiffy new todo list api implemented, lets see if it actually works.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;git:(master) ✗ -!? » curl -i localhost:8765
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:56:01 GMT
Content-Length: 3

[]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;git:(master) ✗ -!? » curl -i localhost:8765 -d &amp;quot;{\&amp;quot;description\&amp;quot;:\&amp;quot;message $RANDOM\&amp;quot;}&amp;quot;
HTTP/1.1 415 Unsupported Media Type
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:56:11 GMT
Content-Length: 157

{&amp;quot;code&amp;quot;:415,&amp;quot;message&amp;quot;:&amp;quot;unsupported media type \&amp;quot;application/x-www-form-urlencoded\&amp;quot;, only [application/io.goswagger.examples.todo-list.v1+json] are allowed&amp;quot;}                                                                                                     ± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;git:(master) ✗ -!? » curl -i localhost:8765 -d &amp;quot;{\&amp;quot;description\&amp;quot;:\&amp;quot;message $RANDOM\&amp;quot;}&amp;quot; -H &#39;Content-Type: application/io.goswagger.examples.todo-list.v1+json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 201 Created
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:56:20 GMT
Content-Length: 39

{&amp;quot;description&amp;quot;:&amp;quot;message 30925&amp;quot;,&amp;quot;id&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
git:(master) ✗ -!? » curl -i localhost:8765 -d &amp;quot;{\&amp;quot;description\&amp;quot;:\&amp;quot;message $RANDOM\&amp;quot;}&amp;quot; -H &#39;Content-Type: application/io.goswagger.examples.todo-list.v1+json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 201 Created
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:56:23 GMT
Content-Length: 37

{&amp;quot;description&amp;quot;:&amp;quot;message 104&amp;quot;,&amp;quot;id&amp;quot;:2}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
git:(master) ✗ -!? » curl -i localhost:8765 -d &amp;quot;{\&amp;quot;description\&amp;quot;:\&amp;quot;message $RANDOM\&amp;quot;}&amp;quot; -H &#39;Content-Type: application/io.goswagger.examples.todo-list.v1+json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 201 Created
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:56:24 GMT
Content-Length: 39

{&amp;quot;description&amp;quot;:&amp;quot;message 15225&amp;quot;,&amp;quot;id&amp;quot;:3}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
git:(master) ✗ -!? » curl -i localhost:8765
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:56:26 GMT
Content-Length: 117

[{&amp;quot;description&amp;quot;:&amp;quot;message 30925&amp;quot;,&amp;quot;id&amp;quot;:1},{&amp;quot;description&amp;quot;:&amp;quot;message 104&amp;quot;,&amp;quot;id&amp;quot;:2},{&amp;quot;description&amp;quot;:&amp;quot;message 15225&amp;quot;,&amp;quot;id&amp;quot;:3}]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
git:(master) ✗ -!? » curl -i localhost:8765/3 -X PUT -H &#39;Content-Type: application/io.goswagger.examples.todo-list.v1+json&#39; -d &#39;{&amp;quot;description&amp;quot;:&amp;quot;go shopping&amp;quot;}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:56:32 GMT
Content-Length: 37

{&amp;quot;description&amp;quot;:&amp;quot;go shopping&amp;quot;,&amp;quot;id&amp;quot;:3}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
git:(master) ✗ -!? » curl -i localhost:8765
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:56:34 GMT
Content-Length: 115

[{&amp;quot;description&amp;quot;:&amp;quot;message 30925&amp;quot;,&amp;quot;id&amp;quot;:1},{&amp;quot;description&amp;quot;:&amp;quot;message 104&amp;quot;,&amp;quot;id&amp;quot;:2},{&amp;quot;description&amp;quot;:&amp;quot;go shopping&amp;quot;,&amp;quot;id&amp;quot;:3}]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
git:(master) ✗ -!? » curl -i localhost:8765/1 -X DELETE -H &#39;Content-Type: application/io.goswagger.examples.todo-list.v1+json&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 204 No Content
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:57:04 GMT
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shellsession&#34;&gt;± ivan@aether:~/go/src/github.com/go-swagger/go-swagger/examples/tutorials/todo-list/server-complete
git:(master) ✗ -!? » curl -i localhost:8765
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK
Content-Type: application/io.goswagger.examples.todo-list.v1+json
Date: Fri, 01 Jan 2016 19:57:06 GMT
Content-Length: 76

[{&amp;quot;description&amp;quot;:&amp;quot;message 104&amp;quot;,&amp;quot;id&amp;quot;:2},{&amp;quot;description&amp;quot;:&amp;quot;go shopping&amp;quot;,&amp;quot;id&amp;quot;:3}]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>swagger.json generation</title>
      <link>//goswagger.io/generate/spec/</link>
      <pubDate>Mon, 09 Nov 2015 18:58:47 -0800</pubDate>
      
      <guid>//goswagger.io/generate/spec/</guid>
      <description>

&lt;p&gt;The toolkit has a command that will let you generate a swagger spec document from your code.
The command integrates with go doc comments, and makes use of structs when it needs to know of
types.&lt;/p&gt;

&lt;p&gt;Based on the work from &lt;a href=&#34;https://github.com/yvasiyarov/swagger&#34;&gt;https://github.com/yvasiyarov/swagger&lt;/a&gt;&lt;br /&gt;
It uses a similar approach but with expanded annotations and it produces a swagger 2.0 spec.&lt;/p&gt;

&lt;p&gt;The goal of the syntax is to make it look as a natural part of the documentation for the application code.&lt;/p&gt;

&lt;p&gt;The generator is passed a main package and it uses that to discover all the code in use.
To do this it makes use of go&amp;rsquo;s loader package. The same package that is used by tools like goimports to discover which files to format.&lt;/p&gt;

&lt;p&gt;Once the parser has encountered a comment that matches on of its known tags, the parser will assume that the rest of the comment block is for swagger.&lt;/p&gt;

&lt;h3 id=&#34;usage:958e7270f96f5407d7d980f500805b1b&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;To generate a spec:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swagger generate spec -o ./swagger.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You give it a main file and it will parse all the files that are reachable by that main
package to produce a swagger specification.&lt;/p&gt;

&lt;p&gt;To use you can add a go:generate comment to your main file for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate swagger generate spec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The command requires a main package or file and it wants your code to compile. It uses the go tools loader to load an application and then scans all the packages that are in use by the code base.
This means that for something to be discoverable it needs to be reachable by a code path triggered through the main package.&lt;/p&gt;

&lt;p&gt;If an annotation is not yet supported or you want to merge with a pre-existing spec, you can use the -i parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swagger generate spec -i ./swagger.yml -o ./swagger.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea is that there are certain things that are more easily expressed by just using yaml, to&lt;/p&gt;

&lt;h4 id=&#34;parsing-rules:958e7270f96f5407d7d980f500805b1b&#34;&gt;Parsing rules&lt;/h4&gt;

&lt;p&gt;&lt;img class=&#34;emoji&#34; title=&#34;:warning&#34; alt=&#34;:warning&#34; src=&#34;https://assets-cdn.github.com/images/icons/emoji/unicode/26a0.png?v5&#34; width=&#34;20&#34; height=&#34;20&#34; align=&#34;absmiddle&#34; /&gt;This command relies heavily on the way godoc works. &lt;img class=&#34;emoji&#34; title=&#34;:warning&#34; alt=&#34;:warning&#34; src=&#34;https://assets-cdn.github.com/images/icons/emoji/unicode/26a0.png?v5&#34; width=&#34;20&#34; height=&#34;20&#34; align=&#34;absmiddle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This means you should be very aware of all the things godoc supports.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/godoc-documenting-go-code&#34;&gt;godoc documenting go code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/go/doc/#ToHTML&#34;&gt;godoc ToHTML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/effective_go.html#commentary&#34;&gt;commenting go effectively&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/godoc&#34;&gt;godoc documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Single page which documents all the currently supported godoc rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/fluhus/godoc-tricks&#34;&gt;godoc tricks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The generated code tries to avoid golint errors.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/lint&#34;&gt;go lint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/CodeReviewComments&#34;&gt;go lint style guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When an object has a title and a description field, it will use the go rules to parse those. So the first line of the
comment block will become the title, or a header when rendered as godoc. The rest of the comment block will be treated
as description up to either the end of the comment block, or a line that starts with a known annotation.&lt;/p&gt;

&lt;h4 id=&#34;annotation-syntax:958e7270f96f5407d7d980f500805b1b&#34;&gt;Annotation syntax&lt;/h4&gt;

&lt;p&gt;If you want to exclude something from the spec generation process you can try with the struct tag: &lt;code&gt;json:&amp;quot;-&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There are several annotations that mark a comment block as a participant for the swagger spec.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;meta&#34;&gt;swagger:meta&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;route&#34;&gt;swagger:route&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;params&#34;&gt;swagger:parameters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;response&#34;&gt;swagger:response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;model&#34;&gt;swagger:model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;allOf&#34;&gt;swagger:allOf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;strfmt&#34;&gt;swagger:strfmt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;discriminated&#34;&gt;swagger:discriminated&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;embedded-types:958e7270f96f5407d7d980f500805b1b&#34;&gt;Embedded types&lt;/h4&gt;

&lt;p&gt;For the embedded schemas there are a set of rules for the spec generator to vary the definition it generates.&lt;br /&gt;
When an embedded type isn&amp;rsquo;t decorated with the &lt;code&gt;swagger:allOf&lt;/code&gt; annotation, then the properties from the embedded value will be included in the generated definition as if they were defined on the definition. But when the embedded type is decorated with the &lt;code&gt;swagger:allOf&lt;/code&gt; annotation then the all of element will be defined as a &amp;ldquo;$ref&amp;rdquo; property instead. For an annotated type there is also the possibility to specify an argument, the value of this argument will be used as the value for the &lt;code&gt;x-class&lt;/code&gt; extension. This allows for generators that support the
&lt;code&gt;x-class&lt;/code&gt; extension to reliably build a serializer for a type with a discriminator&lt;/p&gt;

&lt;h4 id=&#34;known-vendor-extensions:958e7270f96f5407d7d980f500805b1b&#34;&gt;Known vendor extensions&lt;/h4&gt;

&lt;p&gt;There are a couple of commonly used vendor extensions that most frameworks support to add functionality to the swagger spec.&lt;/p&gt;

&lt;p&gt;For generating a swagger specification document this toolkit supports:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Vendor extension&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;x-isnullable&lt;/td&gt;
&lt;td&gt;makes a property value nullable, for go code that means a pointer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x-nullable&lt;/td&gt;
&lt;td&gt;makes a property value nullable, for go code that means a pointer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x-go-name&lt;/td&gt;
&lt;td&gt;the go name of a type&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x-go-package&lt;/td&gt;
&lt;td&gt;the go package of a type&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x-class&lt;/td&gt;
&lt;td&gt;this is used in conjunction with discriminators to give a full type name&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Generate an API client</title>
      <link>//goswagger.io/generate/client/</link>
      <pubDate>Fri, 23 Oct 2015 22:11:54 -0700</pubDate>
      
      <guid>//goswagger.io/generate/client/</guid>
      <description>

&lt;p&gt;The toolkit has a command that will let you generate a client.&lt;/p&gt;

&lt;h2 id=&#34;usage:4bd4f30263398a45e38fc9edfc648efa&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;There is an example client in &lt;a href=&#34;https://github.com/go-swagger/go-swagger/tree/master/examples/todo-list/client&#34;&gt;https://github.com/go-swagger/go-swagger/tree/master/examples/todo-list/client&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To generate a client:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swagger generate client -f [http-url|filepath] -A [application-name] [--principal [principal-name]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to debug what the client is sending and receiving you can set the environment value DEBUG to a non-empty
value.&lt;/p&gt;

&lt;p&gt;Use a default client, which has an HTTP transport:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  &amp;quot;log&amp;quot;

  &amp;quot;github.com/myproject/client/operations&amp;quot;
  &amp;quot;github.com/go-swagger/go-swagger/strfmt&amp;quot;
  &amp;quot;github.com/go-swagger/go-swagger/spec&amp;quot;

  apiclient &amp;quot;github.com/myproject/client&amp;quot;
  httptransport &amp;quot;github.com/go-swagger/go-swagger/httpkit/client&amp;quot;
)

func main() {

  // make the request to get all items
  resp, err := apiclient.Default.Operations.All(operations.AllParams{})
  if err != nil {
    log.Fatal(err)
  }
  fmt.Printf(&amp;quot;%#v\n&amp;quot;, resp.Payload)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The client runtime allows for a number of &lt;a href=&#34;https://godoc.org/github.com/go-swagger/go-swagger/httpkit/client#Runtime&#34;&gt;configuration
options&lt;/a&gt; to be set.&lt;br /&gt;
To then use the client, and override the host, with a HTTP transport:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  &amp;quot;os&amp;quot;
  &amp;quot;log&amp;quot;

  &amp;quot;github.com/myproject/client/operations&amp;quot;
  &amp;quot;github.com/go-swagger/go-swagger/strfmt&amp;quot;
  &amp;quot;github.com/go-swagger/go-swagger/spec&amp;quot;

  apiclient &amp;quot;github.com/myproject/client&amp;quot;
  httptransport &amp;quot;github.com/go-swagger/go-swagger/httpkit/client&amp;quot;
)

func main() {
  // load the swagger spec from URL or local file
  doc, err := spec.Load(&amp;quot;https://raw.githubusercontent.com/go-swagger/go-swagger/master/examples/todo-list/swagger.yml&amp;quot;)
  if err != nil {
    log.Fatal(err)
  }

  // create the transport
  transport := httptransport.New(doc)
  // configure the host
  if os.Getenv(&amp;quot;TODOLIST_HOST&amp;quot;) != &amp;quot;&amp;quot; {
    transport.Host = os.Getenv(&amp;quot;TODOLIST_HOST&amp;quot;)
  }

  // create the API client, with the transport
  client := apiclient.New(transport, strfmt.Default)

  // to override the host for the default client
  // apiclient.Default.SetTransport(transport)

  // make the request to get all items
  resp, err := client.Operations.All(operations.AllParams{})
  if err != nil {
    log.Fatal(err)
  }
  fmt.Printf(&amp;quot;%#v\n&amp;quot;, resp.Payload)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;authentication:4bd4f30263398a45e38fc9edfc648efa&#34;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;The client supports 3 authentication schemes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/go-swagger/go-swagger/httpkit/client#BasicAuth&#34;&gt;Basic Auth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/go-swagger/go-swagger/httpkit/client#APIKeyAuth&#34;&gt;API key auth in header or query&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/go-swagger/go-swagger/httpkit/client#BearerToken&#34;&gt;Bearer token header for oauth2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  &amp;quot;os&amp;quot;
  &amp;quot;log&amp;quot;

  &amp;quot;github.com/myproject/client/operations&amp;quot;
  &amp;quot;github.com/go-swagger/go-swagger/strfmt&amp;quot;
  &amp;quot;github.com/go-swagger/go-swagger/spec&amp;quot;

  apiclient &amp;quot;github.com/myproject/client&amp;quot;
  httptransport &amp;quot;github.com/go-swagger/go-swagger/httpkit/client&amp;quot;
)

func main() {
  // load the swagger spec from URL or local file
  doc, err := spec.Load(&amp;quot;./swagger.yml&amp;quot;)
  if err != nil {
    log.Fatal(err)
  }

  // create the API client
  client := apiclient.New(httptransport.New(doc), strfmt.Default)

  // make the authenticated request to get all items
  bearerTokenAuth := httptransport.BearerToken(os.Getenv(&amp;quot;API_ACCESS_TOKEN&amp;quot;))
  // basicAuth := httptransport.BasicAuth(os.Getenv(&amp;quot;API_USER&amp;quot;), os.Getenv(&amp;quot;API_PASSWORD&amp;quot;))
  // apiKeyQueryAuth := httptransport.APIKeyAuth(&amp;quot;apiKey&amp;quot;, &amp;quot;query&amp;quot;, os.Getenv(&amp;quot;API_KEY&amp;quot;))
  // apiKeyHeaderAuth := httptransport.APIKeyAuth(&amp;quot;X-API-TOKEN&amp;quot;, &amp;quot;header&amp;quot;, os.Getenv(&amp;quot;API_KEY&amp;quot;))
  resp, err := client.Operations.All(operations.AllParams{}, bearerTokenAuth)
  // resp, err := client.Operations.All(operations.AllParams{}, basicAuth)
  // resp, err := client.Operations.All(operations.AllParams{}, apiKeyQueryAuth)
  // resp, err := client.Operations.All(operations.AllParams{}, apiKeyHeaderAuth)
  if err != nil {
    log.Fatal(err)
  }
  fmt.Printf(&amp;quot;%#v\n&amp;quot;, resp.Payload)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Use custom tempaltes</title>
      <link>//goswagger.io/generate/templates/</link>
      <pubDate>Tue, 26 Jan 2016 19:32:00 -0500</pubDate>
      
      <guid>//goswagger.io/generate/templates/</guid>
      <description>

&lt;p&gt;When generating a server or client you can specify a directory to load custom templates from
with &lt;code&gt;--template-dir&lt;/code&gt;. It will recursively read all the &lt;code&gt;.gotmpl&lt;/code&gt; files in the directory and
load them as templates.&lt;/p&gt;

&lt;p&gt;Each file will be loaded and define a template named the same as the file without the suffix. If
the file is in a subdirectory the directory name will be included in the template name and the
first character of the next path segment will be uppercased. e.g.
 - template.gotmpl -&amp;gt; template
 - server/test.gotmpl -&amp;gt; serverTest&lt;/p&gt;

&lt;p&gt;You can override the following templates. Check go-swagger/generator/templates for the default
definitions.&lt;/p&gt;

&lt;h1 id=&#34;available-templates:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;Available Templates:&lt;/h1&gt;

&lt;h1 id=&#34;client-templates:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;Client Templates&lt;/h1&gt;

&lt;h2 id=&#34;clientfacade:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;clientFacade&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;client/facade.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;clientparameter:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;clientParameter&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;client/parameter.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;clientresponse:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;clientResponse&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;client/response.gotmpl&lt;/code&gt;
####requires
 - clientresponse
 - schema
 - docstring&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;clientresponse-1:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;clientresponse&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;client/response.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;clientclient:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;clientClient&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;client/client.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;server-templates:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;Server Templates&lt;/h1&gt;

&lt;h2 id=&#34;serverparameter:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;serverParameter&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/parameter.gotmpl&lt;/code&gt;
####requires
 - propertyparamvalidator
 - sliceparambinder&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;sliceparamvalidator:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;sliceparamvalidator&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/parameter.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;serverresponses:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;serverResponses&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/responses.gotmpl&lt;/code&gt;
####requires
 - serverresponse&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;sliceparambinder:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;sliceparambinder&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/parameter.gotmpl&lt;/code&gt;
####requires
 - propertyparamvalidator
 - sliceparambinder&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;serverresponse:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;serverresponse&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/responses.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;serveroperation:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;serverOperation&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/operation.gotmpl&lt;/code&gt;
####requires
 - schema
 - docstring&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;propertyparamvalidator:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;propertyparamvalidator&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/parameter.gotmpl&lt;/code&gt;
####requires
 - validationPrimitive
 - sliceparamvalidator&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;servermain:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;serverMain&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/main.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;bindprimitiveparam:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;bindprimitiveparam&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/parameter.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;serverconfigureapi:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;serverConfigureapi&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/configureapi.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;serverbuilder:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;serverBuilder&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/builder.gotmpl&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;serverdoc:9052f6ca659538a7ad23c7f4f43faadc&#34;&gt;serverDoc&lt;/h2&gt;

&lt;p&gt;Defined in &lt;code&gt;server/doc.gotmpl&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generate a server for a swagger spec</title>
      <link>//goswagger.io/generate/server/</link>
      <pubDate>Sun, 22 Nov 2015 23:19:15 -0800</pubDate>
      
      <guid>//goswagger.io/generate/server/</guid>
      <description>

&lt;p&gt;The toolkit has a command that will let you generate a docker friendly server with support for TLS.
You can configure it through environment variables that are commonly used on PaaS services.&lt;/p&gt;

&lt;p&gt;A generated server uses &lt;em&gt;no reflection&lt;/em&gt; except for an enum validation and the required validation. The server builds all the necessary plans and execution paths at startup time so that at runtime there is only the absolute minimum processing required to respond to requests.&lt;/p&gt;

&lt;p&gt;The default router for go-swagger is &lt;a href=&#34;https://github.com/naoina/denco&#34;&gt;naoina&amp;rsquo;s denco&lt;/a&gt; which is a &lt;a href=&#34;https://github.com/julienschmidt/go-http-routing-benchmark#github&#34;&gt;&lt;strong&gt;very&lt;/strong&gt; fast&lt;/a&gt; ternary search tree based router that allows for much greater flexibility than the trie based router implementation of julienschmidt at almost the same and sometimes lower cost.&lt;/p&gt;

&lt;p&gt;You can provide your own router implementation should you so desire it&amp;rsquo;s abstracted through an interface with this use case in mind.&lt;/p&gt;

&lt;h5 id=&#34;usage:3c3fb84840715ff4411349984ebc0a77&#34;&gt;Usage&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;swagger generate server [server-OPTIONS]

[server command options]
      -f, --spec=            the spec file to use (default: ./swagger.json)
      -a, --api-package=     the package to save the operations (default: operations)
      -m, --model-package=   the package to save the models (default: models)
      -s, --server-package=  the package to save the server specific code (default: restapi)
      -c, --client-package=  the package to save the client specific code (default: client)
      -t, --target=          the base directory for generating the files (default: ./)
      -A, --name=            the name of the application, defaults to a mangled value of info.title
      -O, --operation=       specify an operation to include, repeat for multiple
          --tags=            the tags to include, if not specified defaults to all
      -P, --principal=       the model to use for the security principal
          --default-scheme=  the default scheme for this API (default: http)
      -M, --model=           specify a model to include, repeat for multiple
          --skip-models      no models will be generated when this flag is specified
          --skip-operations  no operations will be generated when this flag is specified
          --skip-support     no supporting files will be generated when this flag is specified
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The server application gets generated with all the handlers stubbed out with a not implemented handler. That means that you can start the API server immediately after generating it. It will respond to all valid requests with 501 Not Implemented. When a request is invalid it will most likely respond with an appropriate 4xx response.&lt;/p&gt;

&lt;p&gt;The generated server allows for a number of command line parameters to customize it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--host=            the IP to listen on (default: localhost) [$HOST]
--port=            the port to listen on for insecure connections, defaults to a random value [$PORT]
--tls-host=        the IP to listen on for tls, when not specified it&#39;s the same as --host [$TLS_HOST]
--tls-port=        the port to listen on for secure connections, defaults to a random value [$TLS_PORT]
--tls-certificate= the certificate to use for secure connections [$TLS_CERTIFICATE]
--tls-key=         the private key to use for secure conections [$TLS_PRIVATE_KEY]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The server takes care of a number of things when a request arrives:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;routing&lt;/li&gt;
&lt;li&gt;authentication&lt;/li&gt;
&lt;li&gt;input validation&lt;/li&gt;
&lt;li&gt;content negotiation&lt;/li&gt;
&lt;li&gt;parameter and body binding&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To illustrate this with a pseudo handler, this is what happens in a request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  &amp;quot;net/http&amp;quot;

  &amp;quot;github.com/go-swagger/go-swagger/errors&amp;quot;
  &amp;quot;github.com/go-swagger/go-swagger/httpkit/middleware&amp;quot;
  &amp;quot;github.com/gorilla/context&amp;quot;
)

func newCompleteMiddleware(ctx *middleware.Context) http.Handler {
  return http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
    defer context.Clear(r)

    // use context to lookup routes
    if matched, ok := ctx.RouteInfo(r); ok {

      if len(matched.Authenticators) &amp;gt; 0 {
        if _, err := ctx.Authorize(r, matched); err != nil {
          ctx.Respond(rw, r, matched.Produces, matched, err)
          return
        }
      }

      bound, validation := ctx.BindAndValidate(r, matched)
      if validation != nil {
        ctx.Respond(rw, r, matched.Produces, matched, validation)
        return
      }

      result, err := matched.Handler.Handle(bound)
      if err != nil {
        ctx.Respond(rw, r, matched.Produces, matched, err)
        return
      }

      ctx.Respond(rw, r, matched.Produces, matched, result)
      return
    }

    // Not found, check if it exists in the other methods first
    if others := ctx.AllowedMethods(r); len(others) &amp;gt; 0 {
      ctx.Respond(rw, r, ctx.spec.RequiredProduces(), nil, errors.MethodNotAllowed(r.Method, others))
      return
    }
    ctx.Respond(rw, r, ctx.spec.RequiredProduces(), nil, errors.NotFound(&amp;quot;path %s was not found&amp;quot;, r.URL.Path))
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prior to handling requests however you probably want to configure the API with some actual implementations.  To do that you have to edit the configure_xxx_api.go file.  That file will only be generated the first time you generate a server application from a swagger spec. So the generated server uses this file to let you fill in the blanks.&lt;/p&gt;

&lt;p&gt;For the todolist application that file looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;github.com/go-swagger/go-swagger/errors&amp;quot;
	&amp;quot;github.com/go-swagger/go-swagger/httpkit&amp;quot;
	&amp;quot;github.com/go-swagger/go-swagger/httpkit/middleware&amp;quot;

	&amp;quot;github.com/go-swagger/go-swagger/examples/todo-list/restapi/operations&amp;quot;
	&amp;quot;github.com/go-swagger/go-swagger/examples/todo-list/restapi/operations/todos&amp;quot;
)

// This file is safe to edit. Once it exists it will not be overwritten

func configureAPI(api *operations.ToDoListAPI) http.Handler {
	// configure the api here
	api.JSONConsumer = httpkit.JSONConsumer()

	api.JSONProducer = httpkit.JSONProducer()

	api.KeyAuth = func(token string) (interface{}, error) {
		return nil, errors.NotImplemented(&amp;quot;api key auth (key) x-petstore-token from header has not yet been implemented&amp;quot;)
	}

	api.AddOneHandler = todos.AddOneHandlerFunc(func(params todos.AddOneParams, principal interface{}) middleware.Responder {
		return middleware.NotImplemented(&amp;quot;operation addOne has not yet been implemented&amp;quot;)
	})
	api.DestroyOneHandler = todos.DestroyOneHandlerFunc(func(params todos.DestroyOneParams, principal interface{}) middleware.Responder {
		return middleware.NotImplemented(&amp;quot;operation destroyOne has not yet been implemented&amp;quot;)
	})
	api.FindHandler = todos.FindHandlerFunc(func(params todos.FindParams, principal interface{}) middleware.Responder {
		return middleware.NotImplemented(&amp;quot;operation find has not yet been implemented&amp;quot;)
	})
	api.UpdateOneHandler = todos.UpdateOneHandlerFunc(func(params todos.UpdateOneParams, principal interface{}) middleware.Responder {
		return middleware.NotImplemented(&amp;quot;operation updateOne has not yet been implemented&amp;quot;)
	})

	return setupGlobalMiddleware(api.Serve(setupMiddlewares))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you look at the code for the configureAPI method then you&amp;rsquo;ll notice that the api object has properties for consumers.
A consumer is an object that can marshal things from a wireformat to an object.  Consumers and their counterpart producers who write objects get their names generated from the consumes and produces properties on a swagger specification.&lt;/p&gt;

&lt;p&gt;The interface definitions for consumers and producers look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ConsumerFunc represents a function that can be used as a consumer
type ConsumerFunc func(io.Reader, interface{}) error

// Consume consumes the reader into the data parameter
func (fn ConsumerFunc) Consume(reader io.Reader, data interface{}) error {
	return fn(reader, data)
}

// Consumer implementations know how to bind the values on the provided interface to
// data provided by the request body
type Consumer interface {
	// Consume performs the binding of request values
	Consume(io.Reader, interface{}) error
}

// ProducerFunc represents a function that can be used as a producer
type ProducerFunc func(io.Writer, interface{}) error

// Produce produces the response for the provided data
func (f ProducerFunc) Produce(writer io.Writer, data interface{}) error {
	return f(writer, data)
}

// Producer implementations know how to turn the provided interface into a valid
// HTTP response
type Producer interface {
	// Produce writes to the http response
	Produce(io.Writer, interface{}) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it&amp;rsquo;s something that can turn a reader into a hydrated interface. A producer is the counterpart of a consumer and writes objects to an io.Writer.  When you configure an api with those you make sure it can marshal the types for the supported content types.&lt;/p&gt;

&lt;p&gt;The next thing that happens in the configureAPI method is setting up the authentication with a stub handler in this case. This particular swagger specification supports token based authentication and as such it wants you to configure a token auth handler.  Any error for an authentication handler is assumed to be an invalid authentication and will return the 401 status code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// UserPassAuthentication authentication function
type UserPassAuthentication func(string, string) (interface{}, error)

// TokenAuthentication authentication function
type TokenAuthentication func(string) (interface{}, error)

// AuthenticatorFunc turns a function into an authenticator
type AuthenticatorFunc func(interface{}) (bool, interface{}, error)

// Authenticate authenticates the request with the provided data
func (f AuthenticatorFunc) Authenticate(params interface{}) (bool, interface{}, error) {
	return f(params)
}

// Authenticator represents an authentication strategy
// implementations of Authenticator know how to authenticate the
// request data and translate that into a valid principal object or an error
type Authenticator interface {
	Authenticate(interface{}) (bool, interface{}, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we finally get to configuring our route handlers. For each operation there exists an interface so that implementations have some freedom to provide alternative implentations. For example mocks in certain tests, automatic stubbing handlers, not implemented handlers. Let&amp;rsquo;s look at the addOne handler in a bit more detail.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AddOneHandlerFunc turns a function with the right signature into a add one handler
type AddOneHandlerFunc func(AddOneParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn AddOneHandlerFunc) Handle(params AddOneParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// AddOneHandler interface for that can handle valid add one params
type AddOneHandler interface {
	Handle(AddOneParams, interface{}) middleware.Responder
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the &lt;code&gt;addOne&lt;/code&gt; operation requires authentication, this interface definition requires 2 arguments. The first argument is about the request parameters and the second parameter is the security principal for the request.  In this case it is of type &lt;code&gt;interface{}&lt;/code&gt;, typically that is a type like Account, User, Session, &amp;hellip;&lt;/p&gt;

&lt;p&gt;It is your job to provide such a handler. Go swagger guarantees that by the time the request processing ends up at the handler, the parameters and security principal have been bound and validated.  So you can safely proceed with saving the request body to some persistence medium perhaps.&lt;/p&gt;

&lt;p&gt;There is a context that gets created where the handlers get wired up into a &lt;code&gt;http.Handler&lt;/code&gt;. For the add one this looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NewAddOne creates a new http.Handler for the add one operation
func NewAddOne(ctx *middleware.Context, handler AddOneHandler) *AddOne {
	return &amp;amp;AddOne{Context: ctx, Handler: handler}
}

/*AddOne swagger:route POST / todos addOne

AddOne add one API

*/
type AddOne struct {
	Context *middleware.Context
	Params  AddOneParams
	Handler AddOneHandler
}

func (o *AddOne) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, _ := o.Context.RouteInfo(r)

	uprinc, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc
	}

	if err := o.Context.BindValidRequest(r, route, &amp;amp;o.Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(o.Params, principal) // actually handle the request

	o.Context.Respond(rw, r, route.Produces, route, res)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;http.Handler&lt;/code&gt; implementation takes care of authentication, binding, user code execution and generating a response. For authentication this request would end up in the &lt;code&gt;TokenAuthentication&lt;/code&gt; handler that was put on the api context object earlier.  When a request is authenticated it gets bound. This operation eventually requires an object that is an implementation of &lt;code&gt;RequestBinder&lt;/code&gt;.  The &lt;code&gt;AddOneParams&lt;/code&gt; are such an implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RequestBinder is an interface for types to implement
// when they want to be able to bind from a request
type RequestBinder interface {
	BindRequest(*http.Request, *MatchedRoute) error
}

// AddOneParams contains all the bound params for the add one operation
// typically these are obtained from a http.Request
//
// swagger:parameters addOne
type AddOneParams struct {
	/*
	  In: body
	*/
	Body *models.Item
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls
func (o *AddOneParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	var body models.Item
	if err := route.Consumer.Consume(r.Body, &amp;amp;body); err != nil {
		res = append(res, errors.NewParseError(&amp;quot;body&amp;quot;, &amp;quot;body&amp;quot;, &amp;quot;&amp;quot;, err))
	} else {
		if err := body.Validate(route.Formats); err != nil {
			res = append(res, err)
		}

		if len(res) == 0 {
			o.Body = &amp;amp;body
		}
	}

	if len(res) &amp;gt; 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example there is only a body parameter, so we make use of the selected consumer to read the request body and turn it into an instance of models.Item. When the body parameter is bound, it gets validated and when validation passes no error is returned and the body property is set.  After a request is bound and validated the parameters and security principal are passed to the request handler. For this configuration that would return a 501 responder.&lt;/p&gt;

&lt;p&gt;Go swagger uses responders which are an interface implementation for things that can write to a response. For the generated server there are status code response and a default response object generated for every entry in the spec. For the &lt;code&gt;addOne&lt;/code&gt; operation that are 2 objects one for the success case (201) and one for an error (default).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Responder is an interface for types to implement
// when they want to be considered for writing HTTP responses
type Responder interface {
	WriteResponse(http.ResponseWriter, httpkit.Producer)
}

/*AddOneCreated Created

swagger:response addOneCreated
*/
type AddOneCreated struct {

	// In: body
	Payload *models.Item `json:&amp;quot;body,omitempty&amp;quot;`
}

// WriteResponse to the client
func (o *AddOneCreated) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer) {

	rw.WriteHeader(201)
	if o.Payload != nil {
		if err := producer.Produce(rw, o.Payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

/*AddOneDefault error

swagger:response addOneDefault
*/
type AddOneDefault struct {

	// In: body
	Payload *models.Error `json:&amp;quot;body,omitempty&amp;quot;`
}

// WriteResponse to the client
func (o *AddOneDefault) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer) {

	rw.WriteHeader(500)
	if o.Payload != nil {
		if err := producer.Produce(rw, o.Payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So an implementer of the &lt;code&gt;AddOneHandler&lt;/code&gt; could return one of these 2 objects and go-swagger is able to respect the contract set forward by the spec document.&lt;/p&gt;

&lt;p&gt;So to implement the AddOneHandler you could do something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;todos.AddOneHandlerFunc(func(params todos.AddOneParams, principal interface{}) middleware.Responder {
  created, err := database.Save(params.Body)
  if err != nil {
    return AddOneDefault{models.Error{500, err.Error()}}
  }
  return AddOneCreated{created}
})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Validate a swagger spec</title>
      <link>//goswagger.io/usage/validate/</link>
      <pubDate>Thu, 22 Oct 2015 23:28:09 -0700</pubDate>
      
      <guid>//goswagger.io/usage/validate/</guid>
      <description>

&lt;p&gt;The toolkit has a command to validate swagger specifications for you.
It includes a full json-schema validator and adds some extra validations to ensure the spec is valid.&lt;/p&gt;

&lt;h3 id=&#34;usage:c64148e1a0d4f4de12bdfecb139d0588&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;To validate a specification:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swagger validate [http-url|filepath]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;swagger-2-0-resources:c64148e1a0d4f4de12bdfecb139d0588&#34;&gt;Swagger 2.0 resources&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Specification Documentation: &lt;a href=&#34;https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md&#34;&gt;https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JSON Schema: &lt;a href=&#34;https://github.com/swagger-api/swagger-spec/blob/master/schemas/v2.0/schema.json&#34;&gt;https://github.com/swagger-api/swagger-spec/blob/master/schemas/v2.0/schema.json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;sematic-validation:c64148e1a0d4f4de12bdfecb139d0588&#34;&gt;Sematic Validation&lt;/h3&gt;

&lt;p&gt;All the rules the validator tool supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;validate against jsonschema&lt;/li&gt;
&lt;li&gt;validate extra rules outlined &lt;a href=&#34;https://github.com/apigee-127/sway/blob/master/docs/versions/2.0.md#semantic-validation&#34;&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Rule&lt;/th&gt;
&lt;th&gt;Severity&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;definition can&amp;rsquo;t declare a property that&amp;rsquo;s already defined by one of its ancestors&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;definition&amp;rsquo;s ancestor can&amp;rsquo;t be a descendant of the same model&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each security reference should contain only unique scopes&lt;/td&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each security scope in a security definition should be unique&lt;/td&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;path parameter declarations do not allow empty names &lt;em&gt;(&lt;code&gt;/path/{}&lt;/code&gt; is not valid)&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each api path should be non-verbatim (account for path param names) unique per method&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each path parameter should correspond to a parameter placeholder and vice versa&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each referencable definition must have references&lt;/td&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each definition property listed in the required array must be defined in the properties of the model&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each parameter should have a unique &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;in&lt;/code&gt; combination&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each operation must have an unique &lt;code&gt;operationId&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each operation should have only 1 parameter of type body&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each operation cannot have both a body parameter and a formData parameter&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;each reference must point to a valid object&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;every default value that is specified must validate against the schema for that property&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;every example that is specified must validate against the schema for that property&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;items property is required for all schemas/definitions of type &lt;code&gt;array&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Error&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Use the generated server</title>
      <link>//goswagger.io/use/server/</link>
      <pubDate>Wed, 23 Dec 2015 07:44:06 -0800</pubDate>
      
      <guid>//goswagger.io/use/server/</guid>
      <description>

&lt;p&gt;The generated server serves the API but the default implementation returns 501 Not implemented for everything. Let&amp;rsquo;s
look into using the generated code.&lt;/p&gt;

&lt;p&gt;Go swagger primarily deals with HTTP and originally only supports the stdlib &lt;code&gt;net/http&lt;/code&gt; interface. A typical HTTP
request expects a response.  This is reflected in go-swagger where a handler is typically defined as a function of
input parameters to a responder.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ListTravelsHandler interface {
	Handle(ListTravelsParams) middleware.Responder
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The signature of this handler is one of 2 possible variations. When a handler doesn&amp;rsquo;t use authentication then a handler
interface consists out of input parameters and a responder.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type AddOneAuthenticatedHandler interface {
	Handle(AddOneParams, interface{}) middleware.Responder
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a handler does use authentication then the second argument to the handler function represents the security
principal for your application. You can specify the type name for this principal at generation time by specifying the
-P or &amp;ndash;principal flag.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;swagger generate server -P models.User
swagger generate client -P models.User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you would execute the generate step with that parameter for the security principal then the
AddOneAuthenticatedHandler would look a bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type AddOneAuthenticatedHandler interface {
	Handle(AddOneParams, *models.User) middleware.Responder
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implement-handlers:3c3fb84840715ff4411349984ebc0a77&#34;&gt;Implement handlers&lt;/h2&gt;

&lt;p&gt;A handler is an interface/contract that defines a statically typed representation of the input and output parameters of
an operation on your API.
The tool generates handlers that are stubbed with a NotImplemented response when you first generate the server.&lt;/p&gt;

&lt;h3 id=&#34;the-not-implemented-handler:3c3fb84840715ff4411349984ebc0a77&#34;&gt;The not implemented handler&lt;/h3&gt;

&lt;p&gt;The not implemented handler is actually a not implemented responder, it returns a responder that will always respond
with status code 501 and a message that lets people know it&amp;rsquo;s not the fault of the client that things don&amp;rsquo;t work.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;middleware.NotImplemented(&amp;quot;operation todos.AddOne has not yet been implemented&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;your-own-code:3c3fb84840715ff4411349984ebc0a77&#34;&gt;Your own code&lt;/h3&gt;

&lt;p&gt;Each HTTP request expects a response of some sort, this response might have no data but it&amp;rsquo;s a response none the less.&lt;/p&gt;

&lt;p&gt;Every incoming request is described as a bunch of input parameters which have been validated prior to calling the
handler. So whenever your code is executed, the input parameters are guaranteed to be valid according to what the
swagger specification prescribes.&lt;/p&gt;

&lt;p&gt;All the input parameters have been validated, and the request has been authenticated should it have triggered
authentication.&lt;/p&gt;

&lt;p&gt;You probably want to return something a bit more useful to the users of your API than a not implemented response.&lt;/p&gt;

&lt;p&gt;A possible implementation of the &lt;code&gt;ListTravelsHandler&lt;/code&gt; interface might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type PublicListTravelsOK struct {
  Body []models.Travel
}
func (m *PublicListTravelsOK) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer){
  // generated code here
}

type PublicListTravelsError struct {
  Body models.Error
}
func (m *PublicListTravelsOK) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer){
  // generated code here
}

type PublicListTravelsHandler struct {
  db interface {
    FetchTravels(*PublicListTravelsParams) ([]models.Travel, error)
  }
}

func (m *PublicListTravelsHandler) Handle(params ListTravelsParams) middleware.Responder {
  travels, err := m.db.FetchTravels(&amp;amp;params)
  if err != nil {
    return &amp;amp;PublicListTravelsError{Body: models.Error{Message: err.Error()}}
  }
  return &amp;amp;PublicListTravelsOK{Body: travels}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above we have a handler implementation with a hypothetical database fetch interface. When the handle
method is executed there are 2 possible responses for the provided parameters. There can either be an error in which
case the PublicListTravelsError will be returned, otherwise the PublicListTravelsOK will be returned.&lt;/p&gt;

&lt;p&gt;The code generator has written the remaining code to render that response with the headers etc.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BYO middleware</title>
      <link>//goswagger.io/use/middleware/</link>
      <pubDate>Sat, 26 Dec 2015 15:39:37 -0800</pubDate>
      
      <guid>//goswagger.io/use/middleware/</guid>
      <description>

&lt;p&gt;Go-swagger chose the golang &lt;code&gt;net/http&lt;/code&gt; package as base abstraction. That means that for &lt;em&gt;any&lt;/em&gt; supported transport by the toolkit you can reuse &lt;em&gt;any&lt;/em&gt; middleware existing middlewares that following the stdlib middlware pattern.&lt;/p&gt;

&lt;p&gt;There are several projects providing middleware libraries for weaving all kinds of functionality into your request handling. None of those things are the job of go-swagger, go-swagger just serves your specs.&lt;/p&gt;

&lt;p&gt;The server takes care of a number of things when a request arrives:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;routing&lt;/li&gt;
&lt;li&gt;authentication&lt;/li&gt;
&lt;li&gt;input validation&lt;/li&gt;
&lt;li&gt;content negotiation&lt;/li&gt;
&lt;li&gt;parameter and body binding&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re unfamiliar with the concept of golang net/http middlewares you can read up on it here:&lt;br /&gt;
&lt;a href=&#34;http://www.alexedwards.net/blog/making-and-using-middleware&#34;&gt;Making and Using HTTP Middleware&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Besides serving the swagger specification as an API, the toolkit also serves the actual swagger specification document.
The convention is to use the &lt;code&gt;/swagger.json&lt;/code&gt; location for serving up the specification document, so we serve the
specification at that path.&lt;/p&gt;

&lt;h3 id=&#34;add-middleware:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;Add middleware&lt;/h3&gt;

&lt;p&gt;The generated server allows for 2 extension points to inject middleware in its middlware chain. These have to do with
the lifecycle of a request. You can find those hooks in the configure_xxx_api.go file.&lt;/p&gt;

&lt;p&gt;The first one is to add middleware all the way to the top of the middleware stack. To do this you add them in the
&lt;code&gt;setupGlobalMiddleware&lt;/code&gt; method. This middleware applies to everything in the go-swagger managed API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func setupGlobalMiddleware(handler http.Handler) http.Handler {
	return handler
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second extension point allows for middleware to be injected right before actually handling a matched request.
This excludes the swagger.json document from being affected by this middlware though.  This extension point makes the
middlewares execute right after routing but right before authentication, binding and validation.  You add middlewares
to this point by editing the &lt;code&gt;setupMiddlewares&lt;/code&gt; method in configure_xxx_api.go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func setupMiddlewares(handler http.Handler) http.Handler {
	return handler
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The global middleware is an excellent place to do things like panic handling, request logging or adding metrics.  While
the plain middleware allows you to kind of filter this by request path without having to take care of routing. You also
get access to the full context that the go-swagger toolkit uses throughout the lifecycle of a request.&lt;/p&gt;

&lt;h4 id=&#34;add-logging-and-panic-handling:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;Add logging and panic handling&lt;/h4&gt;

&lt;p&gt;A very common requirement for HTTP API&amp;rsquo;s is to include some form of logging. Another one is to handle panics from your
API requests.  The example for a possible implementation of this uses &lt;a href=&#34;https://github.com/dre1080/recover&#34;&gt;this community provided
middleware&lt;/a&gt; to catch panics.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func setupGlobalMiddleware(handler http.Handler) http.Handler {
  recovery := recover.New(&amp;amp;recover.Options{
    Log: log.Print,
  })
  return recovery(handler)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are tons of middlewares out there, some are framework specific and some frameworks don&amp;rsquo;t really use the plain
vanilla golang net/http as base abstraction. For those you can use a project like &lt;a href=&#34;https://github.com/carbocation/interpose&#34;&gt;interpose&lt;/a&gt; that serves as an adapter
layer so you can still reuse middlewares. Of course nobody is stopping you to just implement your own middlewares.&lt;/p&gt;

&lt;p&gt;For example using interpose to integrate with &lt;a href=&#34;https://github.com/carbocation/interpose/blob/master/middleware/negronilogrus.go&#34;&gt;logrus&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
  interpose &amp;quot;github.com/carbocation/interpose/middleware&amp;quot;
)
func setupGlobalMiddleware(handler http.Handler) http.Handler {
  logViaLogrus := interpose.NegroniLogrus()
  return logViaLogrus(handler)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you can compose these middlewares into a stack using functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func setupGlobalMiddleware(handler http.Handler) http.Handler {
  handlePanic := recover.New(&amp;amp;recover.Options{
    Log: log.Print,
  })

  logViaLogrus := interpose.NegroniLogrus()

  return handlePanic(
    logViaLogrus(
      handler
    )
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;add-rate-limiting:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;Add rate limiting&lt;/h4&gt;

&lt;p&gt;You can also add rate limiting in a similar way. Lets say we just want to rate limit the valid requests to our swagger
API. To do so we could use &lt;a href=&#34;https://github.com/didip/tollbooth&#34;&gt;tollbooth&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func setupMiddlewares(handler http.Handler) http.Handler {
  limiter := tollbooth.NewLimiter(1, time.Second)
  limiter.IPLookups = []string{&amp;quot;RemoteAddr&amp;quot;, &amp;quot;X-Forwarded-For&amp;quot;, &amp;quot;X-Real-IP&amp;quot;}
	return tollbooth.LimitFuncHandler(handler)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with this you&amp;rsquo;ve added rate limitting to your application.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Schema generation rules</title>
      <link>//goswagger.io/use/schemas/</link>
      <pubDate>Sat, 26 Dec 2015 15:39:43 -0800</pubDate>
      
      <guid>//goswagger.io/use/schemas/</guid>
      <description>

&lt;p&gt;Lots of the work of go-swagger is to generate models, which can have all kinds of rules like polymorphism and
validations.  Of course none of this is possible without set of rules and tradeoffs.&lt;/p&gt;

&lt;h3 id=&#34;about-schemas:176038017a790b96307b48b85dc07885&#34;&gt;About schemas&lt;/h3&gt;

&lt;p&gt;The general idea is that you should rarely see interface{} in the generated code.
You get a complete representation of a swagger document in somewhat idiomatic go.&lt;/p&gt;

&lt;p&gt;To do so there is set of mapping patterns that are applied to a spec to go types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;defintion of primitive =&amp;gt; type alias/name&lt;/li&gt;
&lt;li&gt;defintion of array =&amp;gt; type alias/name&lt;/li&gt;
&lt;li&gt;definition of map =&amp;gt; type alias/name&lt;/li&gt;
&lt;li&gt;definition of object with properties =&amp;gt; struct&lt;/li&gt;
&lt;li&gt;definition of ref =&amp;gt; type alias/name&lt;/li&gt;
&lt;li&gt;object with only additional properties =&amp;gt; map[string]T&lt;/li&gt;
&lt;li&gt;object with additional properties and properties =&amp;gt; custom serializer&lt;/li&gt;
&lt;li&gt;schema with schema array in items =&amp;gt; tuple (struct with properties, custom serializer)&lt;/li&gt;
&lt;li&gt;schema with all of =&amp;gt; struct&lt;/li&gt;
&lt;li&gt;all of schema with ref =&amp;gt; embedded value&lt;/li&gt;
&lt;li&gt;all of schema with properties =&amp;gt; properties are included in struct&lt;/li&gt;
&lt;li&gt;adding an all of schema with just &amp;ldquo;x-isnullable&amp;rdquo;: true or &amp;ldquo;x-nullable&amp;rdquo;: true turns
the schema into a pointer when there are only other extension properties provided&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JSONSchema and by extension swagger allow for items that have a fixed size array
with schema&amp;rsquo;s describing the items at each index. This can be combined with additional items
to form some kind of tuple with varargs.
To map this to go it creates a struct that has fixed names and a custom json serializer.&lt;/p&gt;

&lt;p&gt;The code that is generated also gets the doc comments that are used by the scanner
to generate a spec from go code. So that after generation you should be able to reverse
generate a spec from the code that was generated by your spec.&lt;/p&gt;

&lt;p&gt;It should be equivalent to the original spec but might miss some default values and examples.&lt;/p&gt;

&lt;h4 id=&#34;nullability:176038017a790b96307b48b85dc07885&#34;&gt;nullability&lt;/h4&gt;

&lt;p&gt;There are rules around what turns something into a pointer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;structs&lt;/li&gt;
&lt;li&gt;x-nullable, x-isnullable&lt;/li&gt;
&lt;li&gt;primitives where the zero value is valid but fail validation otherwise&lt;/li&gt;
&lt;li&gt;strings minLength &amp;gt; 0 or required results in non-pointer&lt;/li&gt;
&lt;li&gt;numbers min &amp;gt; 0, max &amp;lt; 0 and min &amp;lt; max&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic API definition</title>
      <link>//goswagger.io/tutorial/dynamic/</link>
      <pubDate>Sun, 22 Nov 2015 23:21:52 -0800</pubDate>
      
      <guid>//goswagger.io/tutorial/dynamic/</guid>
      <description>&lt;p&gt;The toolkit supports building a swagger specification entirely with go code. It does allow you to serve a spec up quickly. This is one of the building blocks required to serve up stub API&amp;rsquo;s and to generate a test server with predictable responses, however this is not as bad as it sounds&amp;hellip;&lt;/p&gt;

&lt;p&gt;This tutorial uses the todo list application to serve a swagger based API defined entirely in go code.
Because we know what we want the spec to look like, first we&amp;rsquo;ll just build the entire spec with the interal dsl.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;doc := spec.NewSwagger(&amp;quot;&amp;quot;)
doc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Untyped API server</title>
      <link>//goswagger.io/untyped/server/</link>
      <pubDate>Sun, 22 Nov 2015 23:21:52 -0800</pubDate>
      
      <guid>//goswagger.io/untyped/server/</guid>
      <description>&lt;p&gt;The toolkit supports serving a swagger spec with untyped data. This means that it uses mostly interface{} as params to each operation and as result type. It does allow you to serve a spec up quickly. This is one of the building blocks required to serve up stub API&amp;rsquo;s and to generate a test server with predictable responses.&lt;/p&gt;

&lt;p&gt;In this document we&amp;rsquo;ll use the todo list application to build a server that doesn&amp;rsquo;t use any code generation. So we&amp;rsquo;ll load a predefined swagger specification document and serve it up, while writing a minimal amount of code and try to avoid requiring a type cast.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What is go-swagger</title>
      <link>//goswagger.io/about/</link>
      <pubDate>Wed, 21 Oct 2015 21:54:47 -0700</pubDate>
      
      <guid>//goswagger.io/about/</guid>
      <description>&lt;p&gt;There are 2 axis along which your API and its documentation tend to evolve. This toolkit aims to support you along all
axis and remove the repetitive nature of writing what is essentially boilerplate code for faster iteration times.&lt;/p&gt;

&lt;p&gt;The first one is an artifact of that first meeting where you hash out what your service will do. Hopefully you&amp;rsquo;ve come
up with some document that services as a kind of contract for what the affected people/teams will need to do.
At this stage you want to be able to generate a server, perhaps a client to talk to that server.
It&amp;rsquo;s not inconceivable you want to have your front-end team use mock data for that server and that the backend team
wants to be left in peace while they work on their part of the application.&lt;/p&gt;

&lt;p&gt;This is the &lt;strong&gt;design first&lt;/strong&gt; approach for swagger.&lt;/p&gt;

&lt;p&gt;Now we&amp;rsquo;re moving on to the second iteration of the project and at this stage, there might be a design meeting for the
new features, or they might just be refinements of the previous API&amp;rsquo;s. When no changes are required to the contract,
all is great because people can keep doing what they were doing and everybody is happy.
However it might be that there was a change that is required for the front-end, they need a boolean added to some model
because they want to display an-accepted-terms-and-conditions-checkbox.
The backend can decide to add this to the code, provide the necessary annotation and regenerate the swagger
specification document.&lt;/p&gt;

&lt;p&gt;This is the &lt;strong&gt;code first&lt;/strong&gt; approach for swagger.&lt;/p&gt;

&lt;p&gt;This toolkit aims to support both these modes, remove the repetitive nature of writing what is essentially boilerplate
code. In doing so it tries to stay as close as possible to the go stdlib interfaces, it tries to have no opinions
besides the fact that documentation is important. And it tries to integrate well with the rest of the go ecosystem as
well as the swagger ecosystem.&lt;/p&gt;

&lt;p&gt;A series of contrib projects will add higher level optional functionality so that you can use the generated code with
confidence whether your application is your personal blog or is the next AWS.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>swagger:meta</title>
      <link>//goswagger.io/generate/spec/meta/</link>
      <pubDate>Sat, 14 Nov 2015 19:54:53 -0800</pubDate>
      
      <guid>//goswagger.io/generate/spec/meta/</guid>
      <description>

&lt;p&gt;The &lt;strong&gt;swagger:meta&lt;/strong&gt; annotation flags a file as source for metadata about the API.
This is typically a doc.go file with your package documentation.&lt;/p&gt;

&lt;p&gt;You can specify a Consumes and Produces key which has a new content type on each line
Schemes is a tag that is required and allows for a comma separated string composed of:
http, https, ws or wss&lt;/p&gt;

&lt;p&gt;Host and BasePath can be specified but those values will be defaults,
they should get substituted when serving the swagger spec.&lt;/p&gt;

&lt;p&gt;The description property uses the rest of the comment block as description for the api when not explictily provided&lt;/p&gt;

&lt;h5 id=&#34;syntax:abb586ff2a6b4a7ae7b1b78324299d4e&#34;&gt;Syntax:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;swagger:meta
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;properties:abb586ff2a6b4a7ae7b1b78324299d4e&#34;&gt;Properties:&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Annotation&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Terms Of Service&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;allows for either a url or a free text definition describing the terms of services for the API&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Consumes&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a list of default (global) mime type values, one per line, for the content the API receives&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Produces&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a list of default (global) mime type values, one per line, for the conten the API sends&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Schemes&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a list of default schemes the API accept (possible values: http, https, ws, wss) https is preferred as default when configured&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Version&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the current version of the API&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the host from where the spec is served&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Base path&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the default base path for this API&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Contact&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the name of for the person to contact concerning the API eg. John Doe&amp;nbsp;&amp;lt;john@blogs.com&amp;gt;&amp;nbsp;&lt;a href=&#34;http://john.blogs.com&#34;&gt;http://john.blogs.com&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;License&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the name of the license followed by the URL of the license eg. MIT &lt;a href=&#34;http://opensource.org/license/MIT&#34;&gt;http://opensource.org/license/MIT&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;example:abb586ff2a6b4a7ae7b1b78324299d4e&#34;&gt;Example:&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Package classification Petstore API.
//
// the purpose of this application is to provide an application
// that is using plain go code to define an API
//
// This should demonstrate all the possible comment annotations
// that are available to turn go code into a fully compliant swagger 2.0 spec
//
// Terms Of Service:
//
// there are no TOS at this moment, use at your own risk we take no responsibility
//
//     Schemes: http, https
//     Host: localhost
//     BasePath: /v2
//     Version: 0.0.1
//     License: MIT http://opensource.org/licenses/MIT
//     Contact: John Doe&amp;lt;john.doe@example.com&amp;gt; http://john.doe.com
//
//     Consumes:
//     - application/json
//     - application/xml
//
//     Produces:
//     - application/json
//     - application/xml
//
//
// swagger:meta
package classification
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;result:abb586ff2a6b4a7ae7b1b78324299d4e&#34;&gt;Result&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
swagger: &#39;2.0&#39;
consumes:
  - application/json
  - application/xml
produces:
  - application/json
  - application/xml
schemes:
  - http
  - https
info:
  description: &amp;quot;the purpose of this application is to provide an application\nthat is using plain go code to define an API\n\nThis should demonstrate all the possible comment annotations\nthat are available to turn go code into a fully compliant swagger 2.0 spec&amp;quot;
  title: &#39;Petstore API.&#39;
  termsOfService: &#39;there are no TOS at this moment, use at your own risk we take no responsibility&#39;
  contact: {name: &#39;John Doe&#39;, url: &#39;http://john.doe.com&#39;, email: john.doe@example.com}
  license: {name: MIT, url: &#39;http://opensource.org/licenses/MIT&#39;}
  version: 0.0.1
host: localhost
basePath: /v2
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>swagger:route</title>
      <link>//goswagger.io/generate/spec/route/</link>
      <pubDate>Sat, 14 Nov 2015 20:10:39 -0800</pubDate>
      
      <guid>//goswagger.io/generate/spec/route/</guid>
      <description>

&lt;p&gt;A &lt;strong&gt;swagger:route&lt;/strong&gt; annotation links a path to a method.
This operation gets a unique id, which is used in various places as method name.
One such usage is in method names for client generation for example.&lt;/p&gt;

&lt;p&gt;Because there are many routers available, this tool does not try to parse the paths
you provided to your routing library of choice. So you have to specify your path pattern
yourself in valid swagger syntax.&lt;/p&gt;

&lt;h5 id=&#34;syntax:657749a60c6862d2709238cb94541743&#34;&gt;Syntax:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;swagger:route [method] [path pattern] [?tag1 tag2 tag3] [operation id]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;properties:657749a60c6862d2709238cb94541743&#34;&gt;Properties:&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Annotation&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Consumes&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a list of operation specific mime type values, one per line, for the content the API receives&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Produces&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a list of operation specific mime type values, one per line, for the conten the API sends&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Schemes&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a list of operation specific schemes the API accept (possible values: http, https, ws, wss) https is preferred as default when configured&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Security&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a dictionary of key: []string{scopes}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Responses&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a dictionary of status code to named response&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;example:657749a60c6862d2709238cb94541743&#34;&gt;Example:&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ServeAPI serves the API for this record store
func ServeAPI(host, basePath string, schemes []string) error {

	// swagger:route GET /pets listPets pets users
	//
	// Lists pets filtered by some parameters.
	//
	// This will show all available pets by default.
	// You can get the pets that are out of stock
	//
	//     Consumes:
	//     - application/json
	//     - application/x-protobuf
	//
	//     Produces:
	//     - application/json
	//     - application/x-protobuf
	//
	//     Schemes: http, https, ws, wss
	//
	//     Security:
	//       api_key:
	//       oauth: read, write
	//
	//     Responses:
	//       default: genericError
	//       200: someResponse
	//       422: validationError
	mountItem(&amp;quot;GET&amp;quot;, basePath+&amp;quot;/pets&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;result:657749a60c6862d2709238cb94541743&#34;&gt;Result:&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
operations:
  &amp;quot;/&amp;quot;:
    get:
      operationId: listPets
      tags:
      - pets
      - users
      consumes:
      - application/json
      - application/x-protobuf
      produces:
      - application/json
      - application/x-protobuf
      schemes:
      - http
      - https
      - ws
      - wss
      security:
        api_key: []
        oauth:
        - read
        - write
      responses:
        default:
          $ref: &amp;quot;#/responses/genericError&amp;quot;
        200:
          $ref: &amp;quot;#/responses/someResponse&amp;quot;
        422:
          $ref: &amp;quot;#/responses/validationError&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>swagger:parameters</title>
      <link>//goswagger.io/generate/spec/params/</link>
      <pubDate>Sat, 14 Nov 2015 20:10:43 -0800</pubDate>
      
      <guid>//goswagger.io/generate/spec/params/</guid>
      <description>

&lt;p&gt;The &lt;strong&gt;swagger:parameters&lt;/strong&gt; annotation links a struct to one or more operations. The parameters in the resulting swagger spec can be composed of several structs.
There are no guarantees given on how property name overlaps are resolved when several structs apply to the same operation.
This tag works very similar to the swagger:model tag except that it produces valid parameter objects instead of schema
objects.&lt;/p&gt;

&lt;p&gt;When this appears anywhere in a comment for a struct, then that struct becomes a schema
in the definitions object of swagger.&lt;/p&gt;

&lt;p&gt;The struct gets analyzed and all the collected models are added to the tree.
The refs are tracked separately so that they can be renamed later on.&lt;/p&gt;

&lt;p&gt;At this moment the parameters require one or more structs to be defined, it&amp;rsquo;s not possible to annotate plain var
entries at this moment.&lt;/p&gt;

&lt;h5 id=&#34;syntax:9db9435dae1c8dccdc174235ed54a579&#34;&gt;Syntax:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;swagger:parameters [operationid1 operationid2]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;properties:9db9435dae1c8dccdc174235ed54a579&#34;&gt;Properties:&lt;/h5&gt;

&lt;p&gt;The fields of this struct can be decorated with a number of annotations. For the field name it uses the struct field
name, it respects the json struct field tag for customizing the name.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Annotation&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;In&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;where to find the parameter&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Collection Format&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;when a slice the formatter for the collection when serialized on the request&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Maximum&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;specifies the maximum a number or integer value can have&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Minimum&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;specifies the minimum a number or integer value can have&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Multiple of&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;specifies a value a number or integer value must be a multiple of&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Minimum length&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the minimum length for a string value&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Maximum length&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the maximum length for a string value&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Pattern&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a regular expression a string value needs to match&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Minimum items&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the minimum number of items a slice needs to have&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Maximum items&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the maximum number of items a slice can have&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Unique&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;when set to true the slice can only contain unique items&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;when set to true this value needs to be present in the request&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;For slice properties there are also items to be defined. This might be a nested collection, for indicating nesting
level the value is a 0-based index, so items.minLength is the same as items.0.minLength&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Annotation&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Maximum&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;specifies the maximum a number or integer value can have at the level &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Minimum&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;specifies the minimum a number or integer value can have at the level &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Multiple of&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;specifies a value a number or integer value must be a multiple of&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Minimum length&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the minimum length for a string value at the level &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Maximum length&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the maximum length for a string value at the level &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Pattern&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a regular expression a string value needs to match at the level &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Minimum items&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the minimum number of items a slice needs to have at the level &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Maximum items&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;the maximum number of items a slice can have at the level &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Items.&lt;em&gt;n&lt;/em&gt;.Unique&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;when set to true the slice can only contain unique items at the level &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;example:9db9435dae1c8dccdc174235ed54a579&#34;&gt;Example:&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// swagger:parameter listBars addBars
type BarSliceParam struct {
	// a BarSlice has bars which are strings
	//
	// min items: 3
	// max items: 10
	// unique: true
	// items.minItems: 4
	// items.maxItems: 9
	// items.items.minItems: 5
	// items.items.maxItems: 8
	// items.items.items.minLength: 3
	// items.items.items.maxLength: 10
	// items.items.items.pattern: \w+
	// collection format: pipe
	// in: query
	BarSlice [][][]string `json:&amp;quot;bar_slice&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;result:9db9435dae1c8dccdc174235ed54a579&#34;&gt;Result:&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
operations:
  &amp;quot;/&amp;quot;:
    get:
      operationId: listBars
      parameters:
        - name: bar_slice
          in: query
          maxItems: 10 
          minItems: 3
          unique: true
          collectionFormat: pipe
          type: array
          items:
            type: array
            maxItems: 9
            minItems: 4
            items:
              type: array
              maxItems: 8
              minItems: 5
              items:
                type: string
                minLength: 3
                maxLength: 10
                pattern: &amp;quot;\\w+&amp;quot;
    post:
      operationId: addBars
      parameters:
        - name: bar_slice
          in: query
          maxItems: 10 
          minItems: 3
          unique: true
          collectionFormat: pipe
          type: array
          items:
            type: array
            maxItems: 9
            minItems: 4
            items:
              type: array
              maxItems: 8
              minItems: 5
              items:
                type: string
                minLength: 3
                maxLength: 10
                pattern: &amp;quot;\\w+&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>